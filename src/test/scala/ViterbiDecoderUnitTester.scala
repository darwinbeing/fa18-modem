package modem

import dsptools.DspTester

class ViterbiDecoderUnitTester[T <: chisel3.Data](c: ViterbiDecoder[T]) extends DspTester(c) {
  poke(c.io.inReady, 1)
  poke(c.io.out.ready, 1)
  poke(c.io.in(0), 1)
  poke(c.io.in(1), 1)
  poke(c.io.in(2), 1)
  poke(c.io.in(3), -1)
  poke(c.io.in(4), 1)
  poke(c.io.in(5), 1)
  poke(c.io.in(6), -1)
  poke(c.io.in(7), -1)
  poke(c.io.in(8), -1)  // 0
  poke(c.io.in(9), 1)
  poke(c.io.in(10), 1)  // 00
  poke(c.io.in(11), -1)
  poke(c.io.in(12), -1) // 000
  poke(c.io.in(13), -1)
  poke(c.io.in(14), -1) // 0000
  poke(c.io.in(15), -1)
  poke(c.io.in(16), -1) // 00000
  poke(c.io.in(17), -1)
  poke(c.io.in(18), -1) // 000000
  poke(c.io.in(19), -1)
  expect(c.io.out_dp(0), 0)
  expect(c.io.out_dp(1), 0)
  expect(c.io.out_pm(0), 0)
  expect(c.io.out_pm(1), 0)
  expect(c.io.out_pm(2), 0)
  expect(c.io.out_pm(3), 0)
  expect(c.io.out_sp(0), 0)
  expect(c.io.out_sp(1), 0)
  expect(c.io.out_sp(2), 0)
  expect(c.io.out_sp(3), 0)
  expect(c.io.out.valid, 0)
  step(1)                                   // 11, o_cnt = 2
  expect(c.io.out_dp(0), 1)
  expect(c.io.out_dp(1), 1)
  expect(c.io.out_pm(0), 0)
  expect(c.io.out_pm(1), 100)
  expect(c.io.out_pm(2), 100)
  expect(c.io.out_pm(3), 100)
  expect(c.io.out_sp(0), 0)
  expect(c.io.out_sp(1), 0)
  expect(c.io.out_sp(2), 0)
  expect(c.io.out_sp(3), 0)
  expect(c.io.out.valid, 0)
  step(1)                                   // 10, o_cnt = 4
  expect(c.io.out_dp(0), 1)
  expect(c.io.out_dp(1), -1)
  expect(c.io.out_pm(0), 2)
  expect(c.io.out_pm(1), 100)
  expect(c.io.out_pm(2), 0)
  expect(c.io.out_pm(3), 101)
  expect(c.io.out_sp(0), 0)
  expect(c.io.out_sp(1), 2)
  expect(c.io.out_sp(2), 0)
  expect(c.io.out_sp(3), 3)
  expect(c.io.out.valid, 0)
  step(1)                                   // 01, o_cnt = 6
  expect(c.io.out_dp(0), 1)
  expect(c.io.out_dp(1), 1)
  expect(c.io.out_pm(0), 3)
  expect(c.io.out_pm(1), 1)
  expect(c.io.out_pm(2), 3)
  expect(c.io.out_pm(3), 1)
  expect(c.io.out_sp(0), 0)
  expect(c.io.out_sp(1), 2)
  expect(c.io.out_sp(2), 0)
  expect(c.io.out_sp(3), 2)
  expect(c.io.out.valid, 0)
  step(1)                                   // 11, o_cnt = 8
  expect(c.io.out_dp(0), -1)
  expect(c.io.out_dp(1), -1)
  expect(c.io.out_pm(0), 2)
  expect(c.io.out_pm(1), 2)
  expect(c.io.out_pm(2), 2)
  expect(c.io.out_pm(3), 2)
  expect(c.io.out_sp(0), 1)
  expect(c.io.out_sp(1), 3)
  expect(c.io.out_sp(2), 1)
  expect(c.io.out_sp(3), 3)
  expect(c.io.out.valid, 0)
  step(1)
  expect(c.io.out_dp(0), -1)
  expect(c.io.out_dp(1), 1)
  expect(c.io.out_pm(0), 2)
  expect(c.io.out_pm(1), 3)
  expect(c.io.out_pm(2), 3)
  expect(c.io.out_pm(3), 2)
  expect(c.io.out_sp(0), 0)
  expect(c.io.out_sp(1), 3)
  expect(c.io.out_sp(2), 1)
  expect(c.io.out_sp(3), 2)
  expect(c.io.out.valid, 0)
  step(1)
  expect(c.io.out_dp(0), 1)
  expect(c.io.out_dp(1), -1)
  expect(c.io.out_pm(0), 3)
  expect(c.io.out_pm(1), 2)
  expect(c.io.out_pm(2), 3)
  expect(c.io.out_pm(3), 4)
  expect(c.io.out_sp(0), 0)
  expect(c.io.out_sp(1), 3)
  expect(c.io.out_sp(2), 1)
  expect(c.io.out_sp(3), 3)
  expect(c.io.out.valid, 0)
  step(1)
  expect(c.io.out_dp(0), -1)
  expect(c.io.out_dp(1), -1)
  expect(c.io.out_pm(0), 2)
  expect(c.io.out_pm(1), 4)
  expect(c.io.out_pm(2), 4)
  expect(c.io.out_pm(3), 4)
  expect(c.io.out_sp(0), 1)
  expect(c.io.out_sp(1), 2)
  expect(c.io.out_sp(2), 1)
  expect(c.io.out_sp(3), 3)
  expect(c.io.out.valid, 0)
  step(1)
  expect(c.io.out_dp(0), -1)
  expect(c.io.out_dp(1), -1)
  expect(c.io.out_pm(0), 2)
  expect(c.io.out_pm(1), 5)
  expect(c.io.out_pm(2), 4)
  expect(c.io.out_pm(3), 4)
  expect(c.io.out_sp(0), 0)
  expect(c.io.out_sp(1), 3)
  expect(c.io.out_sp(2), 0)
  expect(c.io.out_sp(3), 2)
  expect(c.io.out.valid, 0)
  step(1)
  expect(c.io.out_dp(0), -1)
  expect(c.io.out_dp(1), -1)
  expect(c.io.out_pm(0), 2)
  expect(c.io.out_pm(1), 5)
  expect(c.io.out_pm(2), 4)
  expect(c.io.out_pm(3), 4)
  expect(c.io.out_sp(0), 0)
  expect(c.io.out_sp(1), 3)
  expect(c.io.out_sp(2), 0)
  expect(c.io.out_sp(3), 2)
  expect(c.io.out.valid, 0)
  step(1)
  expect(c.io.out_dp(0), -1)
  expect(c.io.out_dp(1), -1)
  expect(c.io.out_pm(0), 2)
  expect(c.io.out_pm(1), 5)
  expect(c.io.out_pm(2), 4)
  expect(c.io.out_pm(3), 4)
  expect(c.io.out_sp(0), 0)
  expect(c.io.out_sp(1), 3)
  expect(c.io.out_sp(2), 0)
  expect(c.io.out_sp(3), 2)
  expect(c.io.out.bits(0), 0)
  expect(c.io.out.bits(1), 0)
  expect(c.io.out.bits(2), 1)
  expect(c.io.out.bits(3), 0)
  expect(c.io.out.bits(4), 1)
  expect(c.io.out.valid, 1)
  poke(c.io.in(0), 1)
  poke(c.io.in(1), 1)
  poke(c.io.in(2), 1)
  poke(c.io.in(3), -1)
  poke(c.io.in(4), 1)
  poke(c.io.in(5), 1)
  poke(c.io.in(6), -1)
  poke(c.io.in(7), -1)
  poke(c.io.in(8), -1)
  poke(c.io.in(9), 1)
  poke(c.io.in(10), 1)
  poke(c.io.in(11), -1)
  poke(c.io.in(12), -1)
  poke(c.io.in(13), -1)
  poke(c.io.in(14), -1)
  poke(c.io.in(15), -1)
  poke(c.io.in(16), -1)
  poke(c.io.in(17), -1)
  poke(c.io.in(18), -1)
  poke(c.io.in(19), -1)
  step(1)                                   // 11, o_cnt = 2
  expect(c.io.out_dp(0), 1)
  expect(c.io.out_dp(1), 1)
  expect(c.io.out_pm(0), 2)
  expect(c.io.out_pm(1), 5)
  expect(c.io.out_pm(2), 4)
  expect(c.io.out_pm(3), 4)
  expect(c.io.out_sp(0), 0)
  expect(c.io.out_sp(1), 3)
  expect(c.io.out_sp(2), 0)
  expect(c.io.out_sp(3), 2)
  expect(c.io.out.valid, 0)
  step(1)                                   // 10, o_cnt = 4
  expect(c.io.out_dp(0), 1)
  expect(c.io.out_dp(1), -1)
  expect(c.io.out_pm(0), 4)
  expect(c.io.out_pm(1), 4)
  expect(c.io.out_pm(2), 2)
  expect(c.io.out_pm(3), 5)
  expect(c.io.out_sp(0), 0)
  expect(c.io.out_sp(1), 2)
  expect(c.io.out_sp(2), 0)
  expect(c.io.out_sp(3), 3)
  expect(c.io.out.valid, 0)
  step(1)                                   // 01, o_cnt = 6
  expect(c.io.out_dp(0), 1)
  expect(c.io.out_dp(1), 1)
  expect(c.io.out_pm(0), 4)
  expect(c.io.out_pm(1), 3)
  expect(c.io.out_pm(2), 5)
  expect(c.io.out_pm(3), 3)
  expect(c.io.out_sp(0), 1)
  expect(c.io.out_sp(1), 2)
  expect(c.io.out_sp(2), 0)
  expect(c.io.out_sp(3), 2)
  expect(c.io.out.valid, 0)
  step(1)
  expect(c.io.out_dp(0), -1)
  expect(c.io.out_dp(1), -1)
  expect(c.io.out_pm(0), 4)
  expect(c.io.out_pm(1), 4)
  expect(c.io.out_pm(2), 4)
  expect(c.io.out_pm(3), 4)
  expect(c.io.out_sp(0), 1)
  expect(c.io.out_sp(1), 3)
  expect(c.io.out_sp(2), 1)
  expect(c.io.out_sp(3), 3)
  expect(c.io.out.valid, 0)
  step(1)
  expect(c.io.out_dp(0), -1)
  expect(c.io.out_dp(1), 1)
  expect(c.io.out_pm(0), 4)
  expect(c.io.out_pm(1), 5)
  expect(c.io.out_pm(2), 5)
  expect(c.io.out_pm(3), 4)
  expect(c.io.out_sp(0), 0)
  expect(c.io.out_sp(1), 3)
  expect(c.io.out_sp(2), 1)
  expect(c.io.out_sp(3), 2)
  expect(c.io.out.bits(0), 1)
  expect(c.io.out.bits(1), 0)
  expect(c.io.out.bits(2), 0)
  expect(c.io.out.bits(3), 0)
  expect(c.io.out.bits(4), 0)
  expect(c.io.out.valid, 1)
  step(5)
  expect(c.io.out.bits(0), 0)
  expect(c.io.out.bits(1), 0)
  expect(c.io.out.bits(2), 1)
  expect(c.io.out.bits(3), 0)
  expect(c.io.out.bits(4), 1)
  expect(c.io.out.valid, 1)
}

object FixedViterbiDecoderTester {
  def apply(params: FixedCoding): Boolean = {
    chisel3.iotesters.Driver.execute(Array("-tbn", "firrtl", "-fiwv"), () => new ViterbiDecoder(params)) {
      c => new ViterbiDecoderUnitTester(c)
    }
  }
}
